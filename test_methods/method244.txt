[[[@Override
public void transform(CLImage2d srcImg, CLImage2d subImg, CLImage2d srcDotImg, CLImage2d transImg, CLImage2d dstImg, CLImage2d maskImg, ImageTransformer.Parameters[] parameters, boolean[] inverses, InputData inputData, OutputData outputData) {
    if (inverses != null) {
        for (int i = 0; i < inverses.length; i++) {
            if (inverses[i]) {
                throw new UnsupportedOperationException("Inverse transform not supported.");
            }
        }
    }
    prepareTransforms(H1Buffer, H2Buffer, XBuffer, inputData.pyramidLevel, parameters);
    final int dotSize = parameters[0].size();
    final int localSize = parameters.length > 1 ? parameters.length : (inputData.roiWidth > 32 ? 64 : 32);
    final int globalSize = JavaCVCL.alignCeil(inputData.roiWidth, localSize);
    final int reduceSize = globalSize / localSize;
    // allocate buffers if necessary
    CLBuffer inputBuffer = inputData.getBuffer(context);
    CLBuffer outputBuffer = outputData.getBuffer(context, dotSize, reduceSize);
    CLEventList list = new CLEventList(1);
    // setup kernel
    if (surfaceTransformer != null) {
        // upload H1
        context.writeBuffer(H1Buffer, false);
    }
    // upload H2
    context.writeBuffer(H2Buffer, false);
    // upload X
    context.writeBuffer(XBuffer, false);
    if (inputData.autoWrite) {
        inputData.writeBuffer(context);
    }
    CLImage2d srcImg2 = projectorImageCL[inputData.pyramidLevel];
    CLKernel kernel = null;
    if (subImg == null) {
        assert parameters.length == 1;
        kernel = oneKernel.putArg(srcImg2).putArg(srcImg).putArg(dstImg == null ? transImg : dstImg).putArg(maskImg).putArg(H2Buffer);
    } else if (srcDotImg == null) {
        assert parameters.length == 1;
        kernel = subKernel.putArg(srcImg2).putArg(srcImg).putArg(subImg).putArg(transImg).putArg(dstImg).putArg(maskImg).putArg(H2Buffer);
    } else {
        assert parameters.length == dotSize;
        kernel = dotKernel.putArg(srcImg2).putArg(srcImg).putArg(subImg).putArg(srcDotImg).putArg(maskImg).putArg(H2Buffer);
        // System.out.println(kernel.getWorkGroupSize(context.getCLCommandQueue().getDevice()));
    }
    if (H1Buffer != null) {
        kernel.putArg(H1Buffer);
    } else {
        kernel.putNullArg(nullSize);
    }
    kernel.putArg(XBuffer).putArg(inputBuffer).putArg(outputBuffer).rewind();
    context.executeKernel(kernel, inputData.roiX, 0, 0, globalSize, 1, parameters.length, localSize, 1, parameters.length, // execute program
    list);
    if (reduceSize > 1) {
        reduceKernel.putArg(outputBuffer).rewind();
        context.executeKernel(reduceKernel, 0, reduceSize, reduceSize);
    }
    if (outputData.autoRead) {
        outputData.readBuffer(context);
    }
    // CLEvent event = list.getEvent(0);
    // System.out.println((event.getProfilingInfo(CLEvent.ProfilingCommand.END) -
    // event.getProfilingInfo(CLEvent.ProfilingCommand.START))/1000000.0);
    // long res = q.getDevice().getProfilingTimerResolution();
    // System.out.println(res);
}]]],