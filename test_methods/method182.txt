[[[// --- copy_slot_and_check -----------------------------------------------
// Copy slot 'idx' from the old table to the new table.  If this thread
// confirmed the copy, update the counters and check for promotion.
// 
// Returns the result of reading the volatile _newkvs, mostly as a
// convenience to callers.  We come here with 1-shot copy requests
// typically because the caller has found a Prime, and has not yet read
// the _newkvs volatile - which must have changed from null-to-not-null
// before any Prime appears.  So the caller needs to read the _newkvs
// field to retry his operation in the new table, but probably has not
// read it yet.
private Object[] copy_slot_and_check(NonBlockingHashMap topmap, Object[] oldkvs, int idx, Object should_help) {
    assert chm(oldkvs) == this;
    // VOLATILE READ
    Object[] newkvs = _newkvs;
    // We're only here because the caller saw a Prime, which implies a
    // table-copy is in progress.
    assert newkvs != null;
    if (// Copy the desired slot
    copy_slot(topmap, idx, oldkvs, _newkvs))
        // Record the slot copied
        copy_check_and_promote(topmap, oldkvs, 1);
    // Generically help along any copy (except if called recursively from a helper)
    return (should_help == null) ? newkvs : topmap.help_copy(newkvs);
}]]],