[[[static Mat convert(PIX pix) {
    PIX tempPix = null;
    int dtype = -1;
    int height = pix.h();
    int width = pix.w();
    Mat mat2;
    if (pix.colormap() != null) {
        PIX pix2 = pixRemoveColormap(pix, REMOVE_CMAP_TO_FULL_COLOR);
        tempPix = pix = pix2;
        dtype = CV_8UC4;
    } else if (pix.d() <= 8 || pix.d() == 24) {
        PIX pix2 = null;
        switch(pix.d()) {
            case 1:
                pix2 = pixConvert1To8(null, pix, (byte) 0, (byte) 255);
                break;
            case 2:
                pix2 = pixConvert2To8(pix, (byte) 0, (byte) 85, (byte) 170, (byte) 255, 0);
                break;
            case 4:
                pix2 = pixConvert4To8(pix, 0);
                break;
            case 8:
                pix2 = pix;
                break;
            case 24:
                pix2 = pix;
                break;
            default:
                assert false;
        }
        tempPix = pix = pix2;
        int channels = pix.d() / 8;
        dtype = CV_8UC(channels);
        Mat mat = new Mat(height, width, dtype, pix.data(), 4 * pix.wpl());
        mat2 = new Mat(height, width, CV_8UC(channels));
        // swap bytes if needed
        int[] swap = { 0, channels - 1, 1, channels - 2, 2, channels - 3, 3, channels - 4 }, copy = { 0, 0, 1, 1, 2, 2, 3, 3 }, fromTo = channels > 1 && ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN) ? swap : copy;
        mixChannels(mat, 1, mat2, 1, fromTo, Math.min(channels, fromTo.length / 2));
    } else if (pix.d() == 16) {
        dtype = CV_16UC(pix.d() / 16);
    } else if (pix.d() == 32) {
        dtype = CV_32FC(pix.d() / 32);
    }
    mat2 = new Mat(height, width, dtype, pix.data());
    if (tempPix != null) {
        pixDestroy(tempPix);
    }
    return mat2;
}]]],