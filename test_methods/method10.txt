[[[private void resize(long oldMask, AtomicReferenceArray<E> oldBuffer, long pIndex, E e, Supplier<E> s) {
    assert (e != null && s == null) || (e == null || s != null);
    int newBufferLength = getNextBufferSize(oldBuffer);
    final AtomicReferenceArray<E> newBuffer;
    try {
        newBuffer = allocateRefArray(newBufferLength);
    } catch (OutOfMemoryError oom) {
        assert lvProducerIndex() == pIndex + 1;
        soProducerIndex(pIndex);
        throw oom;
    }
    producerBuffer = newBuffer;
    final int newMask = (newBufferLength - 2) << 1;
    producerMask = newMask;
    final int offsetInOld = modifiedCalcCircularRefElementOffset(pIndex, oldMask);
    final int offsetInNew = modifiedCalcCircularRefElementOffset(pIndex, newMask);
    // element in new array
    soRefElement(newBuffer, offsetInNew, e == null ? s.get() : e);
    // buffer linked
    soRefElement(oldBuffer, nextArrayOffset(oldMask), newBuffer);
    // ASSERT code
    final long cIndex = lvConsumerIndex();
    final long availableInQueue = availableInQueue(pIndex, cIndex);
    RangeUtil.checkPositive(availableInQueue, "availableInQueue");
    // Invalidate racing CASs
    // We never set the limit beyond the bounds of a buffer
    soProducerLimit(pIndex + Math.min(newMask, availableInQueue));
    // make resize visible to the other producers
    soProducerIndex(pIndex + 2);
    // INDEX visible before ELEMENT, consistent with consumer expectation
    // make resize visible to consumer
    soRefElement(oldBuffer, offsetInOld, JUMP);
}]]],