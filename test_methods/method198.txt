[[[// --- resize ------------------------------------------------------------
// Resizing after too many probes.  "How Big???" heuristics are here.
// Callers will (not this routine) will 'help_copy' any in-progress copy.
// Since this routine has a fast cutout for copy-already-started, callers
// MUST 'help_copy' lest we have a path which forever runs through
// 'resize' only to discover a copy-in-progress which never progresses.
private final Object[] resize(NonBlockingIdentityHashMap topmap, Object[] kvs) {
    assert chm(kvs) == this;
    // Check for resize already in progress, probably triggered by another thread
    // VOLATILE READ
    Object[] newkvs = _newkvs;
    if (// See if resize is already in progress
    newkvs != null)
        // Use the new table already
        return newkvs;
    // No copy in-progress, so start one.  First up: compute new table size.
    // Old count of K,V pairs allowed
    int oldlen = len(kvs);
    // Get current table count of active K,V pairs
    int sz = size();
    // First size estimate
    int newsz = sz;
    // Heuristic to determine new size.  We expect plenty of dead-slots-with-keys
    // and we need some decent padding to avoid endless reprobing.
    if (sz >= (oldlen >> 2)) {
        // If we are >25% full of keys then...
        // Double size
        newsz = oldlen << 1;
        if (// If we are >50% full of keys then...
        sz >= (oldlen >> 1))
            // Double double size
            newsz = oldlen << 2;
    }
    // This heuristic in the next 2 lines leads to a much denser table
    // with a higher reprobe rate
    // if( sz >= (oldlen>>1) ) // If we are >50% full of keys then...
    // newsz = oldlen<<1;    // Double size
    // Last (re)size operation was very recent?  Then double again; slows
    // down resize operations for tables subject to a high key churn rate.
    long tm = System.currentTimeMillis();
    long q = 0;
    if (// New table would shrink or hold steady?
    newsz <= oldlen && // Recent resize (less than 1 sec ago)
    tm <= topmap._last_resize_milli + 10000 && // 1/2 of keys are dead?
    (q = _slots.estimate_get()) >= (sz << 1))
        // Double the existing size
        newsz = oldlen << 1;
    // Do not shrink, ever
    if (newsz < oldlen)
        newsz = oldlen;
    // Convert to power-of-2
    int log2;
    // Compute log2 of size
    for (log2 = MIN_SIZE_LOG; (1 << log2) < newsz; log2++) ;
    // Now limit the number of threads actually allocating memory to a
    // handful - lest we have 750 threads all trying to allocate a giant
    // resized array.
    long r = _resizers;
    while (!_resizerUpdater.compareAndSet(this, r, r + 1)) r = _resizers;
    // Size calculation: 2 words (K+V) per table entry, plus a handful.  We
    // guess at 32-bit pointers; 64-bit pointers screws up the size calc by
    // 2x but does not screw up the heuristic very much.
    int megs = ((((1 << log2) << 1) + 4) << 3) >> 20;
    if (r >= 2 && megs > 0) {
        // Already 2 guys trying; wait and see
        // Between dorking around, another thread did it
        newkvs = _newkvs;
        if (// See if resize is already in progress
        newkvs != null)
            // Use the new table already
            return newkvs;
        // TODO - use a wait with timeout, so we'll wakeup as soon as the new table
        // is ready, or after the timeout in any case.
        // synchronized( this ) { wait(8*megs); }         // Timeout - we always wakeup
        // For now, sleep a tad and see if the 2 guys already trying to make
        // the table actually get around to making it happen.
        try {
            Thread.sleep(8l * megs);
        } catch (Exception e) {
        }
    }
    // Last check, since the 'new' below is expensive and there is a chance
    // that another thread slipped in a new thread while we ran the heuristic.
    newkvs = _newkvs;
    if (// See if resize is already in progress
    newkvs != null)
        // Use the new table already
        return newkvs;
    // Double size for K,V pairs, add 1 for CHM
    // This can get expensive for big arrays
    newkvs = new Object[((1 << log2) << 1) + 2];
    // CHM in slot 0
    newkvs[0] = new CHM(_size);
    // hashes in slot 1
    newkvs[1] = new int[1 << log2];
    // Another check after the slow allocation
    if (// See if resize is already in progress
    _newkvs != null)
        // Use the new table already
        return _newkvs;
    // The new table must be CAS'd in so only 1 winner amongst duplicate
    // racing resizing threads.  Extra CHM's will be GC'd.
    if (CAS_newkvs(newkvs)) {
        // NOW a resize-is-in-progress!
        // notifyAll();            // Wake up any sleepers
        // long nano = System.nanoTime();
        // System.out.println(" "+nano+" Resize from "+oldlen+" to "+(1<<log2)+" and had "+(_resizers-1)+" extras" );
        // if( System.out != null ) System.out.print("["+log2);
        // Call for Hashtable's benefit
        topmap.rehash();
    } else
        // CAS failed?
        // Reread new table
        newkvs = _newkvs;
    return newkvs;
}]]],