[[[// Help copy this one word.  State Machine.
// (1) If not "made immutable" in the old array, set the sign bit to make
// it immutable.
// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old
// (3) If non-zero in old array & non-zero in new, CAS old to zero
// (4) Zero in old, new is valid
// At this point, old should be immutable-zero & new has a copy of bits
private NBSI help_copy_impl(int i) {
    // Handle every 64th bit via using a nested array
    // The bit array being copied from
    NBSI old = this;
    // The bit array being copied to
    NBSI nnn = _new;
    // Promoted already
    if (nnn == null)
        return this;
    // The bit index being added
    int j = i;
    while ((j & 63) == 63) {
        // Bit 64? (low 6 bits are all set)
        // Recurse
        old = old._nbsi64;
        // Recurse
        nnn = nnn._nbsi64;
        // Strip off low 6 bits (all set)
        j = j >> 6;
    }
    // Transit from state 1: word is not immutable yet
    // Immutable is in bit 63, the sign bit.
    long bits = old._bits[j >> 6];
    while (bits >= 0) {
        // Still in state (1)?
        long oldbits = bits;
        // Target state of bits: sign-bit means immutable
        bits |= mask(63);
        if (old.CAS(j >> 6, oldbits, bits)) {
            if (oldbits == 0)
                _copyDone.addAndGet(1);
            // Success - old array word is now immutable
            break;
        }
        // Retry if CAS failed
        bits = old._bits[j >> 6];
    }
    // Transit from state 2: non-zero in old and zero in new
    if (bits != mask(63)) {
        // Non-zero in old?
        long new_bits = nnn._bits[j >> 6];
        if (new_bits == 0) {
            // New array is still zero
            // Desired new value: a mutable copy of bits
            new_bits = bits & ~mask(63);
            // One-shot CAS attempt, no loop, from 0 to non-zero.
            // If it fails, somebody else did the copy for us
            if (!nnn.CAS(j >> 6, 0, new_bits))
                // Since it failed, get the new value
                new_bits = nnn._bits[j >> 6];
            assert new_bits != 0;
        }
        // Transit from state 3: non-zero in old and non-zero in new
        // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)
        if (old.CAS(j >> 6, bits, mask(63)))
            // One more word finished copying
            _copyDone.addAndGet(1);
    }
    // Now in state 4: zero (and immutable) in old
    // Return the self bitvector for 'fluid' programming style
    return this;
}]]],