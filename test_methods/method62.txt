[[[private ByteBuffer createByteBufferFromFramedata(Framedata framedata) {
    ByteBuffer mes = framedata.getPayloadData();
    boolean mask = role == Role.CLIENT;
    int sizebytes = getSizeBytes(mes);
    ByteBuffer buf = ByteBuffer.allocate(1 + (sizebytes > 1 ? sizebytes + 1 : sizebytes) + (mask ? 4 : 0) + mes.remaining());
    byte optcode = fromOpcode(framedata.getOpcode());
    byte one = (byte) (framedata.isFin() ? -128 : 0);
    one |= optcode;
    if (framedata.isRSV1()) {
        one |= getRSVByte(1);
    }
    if (framedata.isRSV2()) {
        one |= getRSVByte(2);
    }
    if (framedata.isRSV3()) {
        one |= getRSVByte(3);
    }
    buf.put(one);
    byte[] payloadlengthbytes = toByteArray(mes.remaining(), sizebytes);
    assert (payloadlengthbytes.length == sizebytes);
    if (sizebytes == 1) {
        buf.put((byte) (payloadlengthbytes[0] | getMaskByte(mask)));
    } else if (sizebytes == 2) {
        buf.put((byte) ((byte) 126 | getMaskByte(mask)));
        buf.put(payloadlengthbytes);
    } else if (sizebytes == 8) {
        buf.put((byte) ((byte) 127 | getMaskByte(mask)));
        buf.put(payloadlengthbytes);
    } else {
        throw new IllegalStateException("Size representation not supported/specified");
    }
    if (mask) {
        ByteBuffer maskkey = ByteBuffer.allocate(4);
        maskkey.putInt(reuseableRandom.nextInt());
        buf.put(maskkey.array());
        for (int i = 0; mes.hasRemaining(); i++) {
            buf.put((byte) (mes.get() ^ maskkey.get(i % 4)));
        }
    } else {
        buf.put(mes);
        // Reset the position of the bytebuffer e.g. for additional use
        mes.flip();
    }
    assert (buf.remaining() == 0) : buf.remaining();
    buf.flip();
    return buf;
}]]],