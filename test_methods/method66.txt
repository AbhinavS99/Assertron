[[[public synchronized Frame pullSamples() throws Exception {
    try (PointerScope scope = new PointerScope()) {
        if (!started) {
            throw new Exception("start() was not called successfully!");
        }
        av_frame_unref(filt_frame);
        /* pull a filtered frame from the filtergraph */
        int ret = av_buffersink_get_frame(abuffersink_ctx, filt_frame);
        if (ret == AVERROR_EAGAIN() || ret == AVERROR_EOF()) {
            return null;
        } else if (ret < 0) {
            throw new Exception("av_buffersink_get_frame(): Error occurred: " + av_make_error_string(new BytePointer(256), 256, ret).getString());
        }
        int sample_format = filt_frame.format();
        int planes = av_sample_fmt_is_planar(sample_format) != 0 ? (int) filt_frame.channels() : 1;
        int data_size = av_samples_get_buffer_size((IntPointer) null, filt_frame.channels(), filt_frame.nb_samples(), filt_frame.format(), 1) / planes;
        if (samples_buf == null || samples_buf.length != planes) {
            samples_ptr = new BytePointer[planes];
            samples_buf = new Buffer[planes];
        }
        frame.audioChannels = filt_frame.channels();
        frame.sampleRate = filt_frame.sample_rate();
        frame.samples = samples_buf;
        frame.opaque = filt_frame;
        int sample_size = data_size / av_get_bytes_per_sample(sample_format);
        for (int i = 0; i < planes; i++) {
            BytePointer p = filt_frame.data(i);
            if (!p.equals(samples_ptr[i]) || samples_ptr[i].capacity() < data_size) {
                samples_ptr[i] = p.capacity(data_size);
                ByteBuffer b = p.asBuffer();
                switch(sample_format) {
                    case AV_SAMPLE_FMT_U8:
                    case AV_SAMPLE_FMT_U8P:
                        samples_buf[i] = b;
                        break;
                    case AV_SAMPLE_FMT_S16:
                    case AV_SAMPLE_FMT_S16P:
                        samples_buf[i] = b.asShortBuffer();
                        break;
                    case AV_SAMPLE_FMT_S32:
                    case AV_SAMPLE_FMT_S32P:
                        samples_buf[i] = b.asIntBuffer();
                        break;
                    case AV_SAMPLE_FMT_FLT:
                    case AV_SAMPLE_FMT_FLTP:
                        samples_buf[i] = b.asFloatBuffer();
                        break;
                    case AV_SAMPLE_FMT_DBL:
                    case AV_SAMPLE_FMT_DBLP:
                        samples_buf[i] = b.asDoubleBuffer();
                        break;
                    default:
                        assert false;
                }
            }
            samples_buf[i].position(0).limit(sample_size);
        }
        frame.timestamp = 1000000L * filt_frame.pts() * atime_base.num() / atime_base.den();
        return frame;
    }
}]]],