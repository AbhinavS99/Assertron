[[[public static void flipCopyWithGamma(ByteBuffer srcBuf, int srcBufferIndex, int srcStep, ByteBuffer dstBuf, int dstBufferIndex, int dstStep, boolean signed, double gamma, boolean flip, int channels) {
    assert srcBuf != dstBuf;
    int w = Math.min(srcStep, dstStep);
    int srcLine = srcBufferIndex, dstLine = dstBufferIndex;
    byte[] buffer = new byte[channels];
    while (srcLine < srcBuf.capacity() && dstLine < dstBuf.capacity()) {
        if (flip) {
            srcBufferIndex = srcBuf.capacity() - srcLine - srcStep;
        } else {
            srcBufferIndex = srcLine;
        }
        dstBufferIndex = dstLine;
        w = Math.min(Math.min(w, srcBuf.capacity() - srcBufferIndex), dstBuf.capacity() - dstBufferIndex);
        if (signed) {
            if (channels > 1) {
                for (int x = 0; x < w; x += channels) {
                    for (int z = 0; z < channels; z++) {
                        int in = srcBuf.get(srcBufferIndex++);
                        byte out;
                        if (gamma == 1.0) {
                            out = (byte) in;
                        } else {
                            out = (byte) Math.round(Math.pow((double) in / Byte.MAX_VALUE, gamma) * Byte.MAX_VALUE);
                        }
                        buffer[z] = out;
                    }
                    for (int z = channels - 1; z >= 0; z--) {
                        dstBuf.put(dstBufferIndex++, buffer[z]);
                    }
                }
            } else {
                for (int x = 0; x < w; x++) {
                    int in = srcBuf.get(srcBufferIndex++);
                    byte out;
                    if (gamma == 1.0) {
                        out = (byte) in;
                    } else {
                        out = (byte) Math.round(Math.pow((double) in / Byte.MAX_VALUE, gamma) * Byte.MAX_VALUE);
                    }
                    dstBuf.put(dstBufferIndex++, out);
                }
            }
        } else {
            if (channels > 1) {
                for (int x = 0; x < w; x += channels) {
                    for (int z = 0; z < channels; z++) {
                        byte out;
                        int in = srcBuf.get(srcBufferIndex++) & 0xFF;
                        if (gamma == 1.0) {
                            out = (byte) in;
                        } else if (gamma == 2.2) {
                            out = gamma22[in];
                        } else if (gamma == 1 / 2.2) {
                            out = gamma22inv[in];
                        } else {
                            out = (byte) Math.round(Math.pow((double) in / 0xFF, gamma) * 0xFF);
                        }
                        buffer[z] = out;
                    }
                    for (int z = channels - 1; z >= 0; z--) {
                        dstBuf.put(dstBufferIndex++, buffer[z]);
                    }
                }
            } else {
                for (int x = 0; x < w; x++) {
                    byte out;
                    int in = srcBuf.get(srcBufferIndex++) & 0xFF;
                    if (gamma == 1.0) {
                        out = (byte) in;
                    } else if (gamma == 2.2) {
                        out = gamma22[in];
                    } else if (gamma == 1 / 2.2) {
                        out = gamma22inv[in];
                    } else {
                        out = (byte) Math.round(Math.pow((double) in / 0xFF, gamma) * 0xFF);
                    }
                    dstBuf.put(dstBufferIndex++, out);
                }
            }
        }
        srcLine += srcStep;
        dstLine += dstStep;
    }
}]]],