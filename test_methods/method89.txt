[[[public GNImageAlignerCL(ImageTransformerCL transformer, Parameters initialParameters, CLImage2d template0, double[] roiPts, CLImage2d target0, GNImageAligner.Settings settings) {
    super(transformer, initialParameters);
    setSettings(settings);
    context = transformer.getContext();
    final int minLevel = settings.pyramidLevelMin;
    final int maxLevel = settings.pyramidLevelMax;
    this.template = new IplImage[maxLevel + 1];
    this.target = new IplImage[maxLevel + 1];
    this.transformed = new IplImage[maxLevel + 1];
    this.residual = new IplImage[maxLevel + 1];
    this.mask = new IplImage[maxLevel + 1];
    this.templateCL = new CLImage2d[maxLevel + 1];
    this.targetCL = new CLImage2d[maxLevel + 1];
    this.transformedCL = new CLImage2d[maxLevel + 1];
    this.residualCL = new CLImage2d[maxLevel + 1];
    this.maskCL = new CLGLImage2d[maxLevel + 1];
    this.maskrb = new int[maxLevel + 1];
    this.maskfb = new int[maxLevel + 1];
    int w = template0 != null ? template0.width : target0.width;
    int h = template0 != null ? template0.height : target0.height;
    CLGLContext c = context.getCLGLContext();
    // GLContext glContext = c.getGLContext();
    // glContext.makeCurrent();
    GL2 gl = context.getGL2();
    gl.glGenRenderbuffers(maxLevel + 1, maskrb, 0);
    gl.glGenFramebuffers(maxLevel + 1, maskfb, 0);
    CLImageFormat f = new CLImageFormat(CLImageFormat.ChannelOrder.RGBA, CLImageFormat.ChannelType.FLOAT);
    for (int i = minLevel; i <= maxLevel; i++) {
        templateCL[i] = i == minLevel && template0 != null ? template0 : c.createImage2d(w, h, f);
        targetCL[i] = i == minLevel && target0 != null ? target0 : c.createImage2d(w, h, f);
        transformedCL[i] = c.createImage2d(w, h, f);
        residualCL[i] = c.createImage2d(w, h, f);
        gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER, maskrb[i]);
        gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER, maskfb[i]);
        gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER, GL2.GL_LUMINANCE8, w, h);
        gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER, GL2.GL_COLOR_ATTACHMENT0, GL2.GL_RENDERBUFFER, maskrb[i]);
        assert gl.glCheckFramebufferStatus(GL2.GL_FRAMEBUFFER) == GL2.GL_FRAMEBUFFER_COMPLETE;
        maskCL[i] = c.createFromGLRenderbuffer(maskrb[i]);
        System.out.println(maskCL[i] + " " + maskCL[i].getElementSize() + " " + maskCL[i].getFormat());
        w /= 2;
        h /= 2;
    }
    // glContext.release();
    this.inputData = new InputData();
    this.outputData = new OutputData(false);
    this.templateChanged = new boolean[maxLevel + 1];
    Arrays.fill(templateChanged, true);
    setConstrained(settings.constrained);
    setTemplateImageCL(template0, roiPts);
    setTargetImageCL(target0);
}]]],